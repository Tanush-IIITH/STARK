\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{subcaption}

\usetikzlibrary{arrows,positioning,shapes.geometric}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\title{\textbf{Knuth--Morris--Pratt (KMP) Algorithm for DNA Pattern Matching}}
\author{STARK DNA Pattern Matching Project}
\date{November 2025}

\begin{document}

\maketitle

\begin{abstract}
This report presents a complete overview of the Knuth--Morris--Pratt (KMP) exact string matching algorithm and its application to DNA sequence analysis. We cover the LPS (Longest Proper Prefix which is also Suffix) preprocessing, the linear-time search procedure, correctness, complexity, and empirical performance on both synthetic and real genomic datasets. Results and implementation follow the structure used for Boyer--Moore in this repository, ensuring consistent documentation across algorithms.
\end{abstract}

\section{Introduction}
String matching is central to bioinformatics tasks such as motif search, primer validation, and genome annotation. Given a text $T$ of length $n$ and a pattern $P$ of length $m$, KMP finds all indices $i$ such that $T[i..i+m-1] = P[0..m-1]$.

DNA sequences over the alphabet $\Sigma = \{A, C, G, T\}$ make KMP attractive due to its predictable $O(n)$ worst-case runtime and small memory overhead.

\subsection{Problem Statement}
Input: Text $T$ (DNA), pattern $P$ (DNA). Output: All start positions of $P$ in $T$.

\section{Algorithm Description}
KMP avoids redundant comparisons by preprocessing $P$ into an LPS array. When a mismatch occurs after matching a prefix of $P$, the LPS value indicates where to resume in $P$ without re-checking characters in $T$.

\subsection{LPS (Failure Function)}
For each index $i$ in $P$, $\mathrm{LPS}[i]$ is the length of the longest proper prefix of $P[0..i]$ that is also a suffix of $P[0..i]$. LPS can be computed in $O(m)$ time.

\subsection{Search Procedure}
We scan $T$ left-to-right while maintaining an index $j$ into $P$. On match, advance both indices; on mismatch after $j>0$ matches, fall back to $j = \mathrm{LPS}[j-1]$. If $j=m$, a match is reported and $j$ falls back to $\mathrm{LPS}[m-1]$ to allow overlapping matches.

\section{Complexity Analysis}
\begin{itemize}
    \item Preprocessing (LPS): $O(m)$ time, $O(m)$ space.
    \item Search: $O(n)$ time in the worst case, $O(1)$ extra space beyond LPS and loop variables.
    \item Total: $O(n+m)$ time, $O(m)$ space.
\end{itemize}

\section{Proof of Correctness}
We provide a formal proof of correctness for the KMP algorithm by establishing a loop invariant for the search phase and proving the time complexity bound using amortized analysis.

\subsection{Loop Invariant and Correctness}
We define the invariant for the `while` loop in the search procedure where $i$ is the text index and $j$ is the pattern index. Let $\pi$ denote the failure function table (LPS).

\begin{theorem}[Correctness Invariant]
At the start of each iteration of the `while` loop, $P[0 \dots j-1]$ is the longest prefix of $P$ that is a suffix of $T[0 \dots i-1]$.
\end{theorem}

\begin{proof}
We proceed by induction on the number of loop iterations.
\begin{itemize}
    \item \textbf{Initialization:} Initially $i=0, j=0$. $P[0 \dots -1]$ and $T[0 \dots -1]$ are empty strings $\epsilon$. $\epsilon$ is the longest prefix of $P$ that is a suffix of $\epsilon$. The invariant holds.
    \item \textbf{Maintenance:} Assume the invariant holds at the start of an iteration.
    \begin{enumerate}
        \item \textbf{Case 1 ($T[i] == P[j]$):} We increment both $i$ and $j$. Since $P[0 \dots j-1]$ is a suffix of $T[0 \dots i-1]$ (inductive hypothesis) and $P[j] = T[i]$, it follows that $P[0 \dots j]$ is a suffix of $T[0 \dots i]$. The length of the matching prefix becomes $j+1$, maintaining the invariant.
        \item \textbf{Case 2 ($T[i] \neq P[j]$ and $j > 0$):} We update $j \gets \pi[j-1]$. By the definition of the failure function, the new $P[0 \dots \pi[j-1]-1]$ is the second longest prefix of $P$ that matches the suffix of $T[0 \dots i-1]$. We do not increment $i$, so we re-test against $T[i]$ in the next iteration. This recursive reduction continues until a match is found or $j=0$.
        \item \textbf{Case 3 ($T[i] \neq P[j]$ and $j == 0$):} No prefix of $P$ matches $T[0 \dots i]$. We increment $i$. The longest matching prefix is empty (length 0). The invariant holds.
    \end{enumerate}
    \item \textbf{Termination:} The algorithm terminates when $i = n$. If $j=m$ at any point, a match is recorded, implying $P[0 \dots m-1]$ is a suffix of $T[0 \dots i-1]$.
\end{itemize}
\end{proof}

\subsection{Time Complexity Proof via Potential Function}
To rigorously prove the $O(n)$ time complexity, we use an amortized analysis.
\begin{proof}
Define a potential function $\Phi = 2i - j$.
\begin{itemize}
    \item When $T[i] = P[j]$: $i \to i+1, j \to j+1$. $\Delta \Phi = 2(i+1) - (j+1) - (2i - j) = 1$.
    \item When $T[i] \neq P[j], j > 0$: $i \to i, j \to \pi[j-1]$. Since $\pi[j-1] < j$, $j$ decreases. $\Delta \Phi = 2i - \pi[j-1] - (2i - j) = j - \pi[j-1] \ge 1$.
    \item When $T[i] \neq P[j], j = 0$: $i \to i+1, j \to 0$. $\Delta \Phi = 2(i+1) - 0 - (2i - 0) = 2$.
\end{itemize}
In every step, $\Phi$ increases by at least 1. Since initially $\Phi = 0$ and finally $\Phi \approx 2n$ (as $j < m \le n$), the total number of operations is bounded by $2n$. Thus, the time complexity is $O(n)$.
\end{proof}

\section{Pseudocode}
\subsection{LPS Computation}
\begin{algorithm}[H]
\caption{ComputeLPS($P$)}
\begin{algorithmic}[1]
\State $m \gets |P|$, $\mathrm{LPS}[0] \gets 0$, $len \gets 0$
\For{$i \gets 1$ to $m-1$}
    \While{$len>0$ and $P[i] \ne P[len]$}
        \State $len \gets \mathrm{LPS}[len-1]$
    \EndWhile
    \If{$P[i] = P[len]$}
        \State $len \gets len+1$, $\mathrm{LPS}[i] \gets len$
    \Else
        \State $\mathrm{LPS}[i] \gets 0$
    \EndIf
\EndFor
\State \Return $\mathrm{LPS}$
\end{algorithmic}
\end{algorithm}

\subsection{Search}
\begin{algorithm}[H]
\caption{KMP-Search($T, P$)}
\begin{algorithmic}[1]
\State $n \gets |T|$, $m \gets |P|$, $\mathrm{LPS} \gets \Call{ComputeLPS}{P}$
\State $i \gets 0$, $j \gets 0$, matches $\gets [\,]$
\While{$i < n$}
    \If{$T[i] = P[j]$}
        \State $i\gets i+1$, $j\gets j+1$
        \If{$j = m$}
            \State matches.append($i-j$); $j \gets \mathrm{LPS}[m-1]$
        \EndIf
    \ElsIf{$j > 0$}
        \State $j \gets \mathrm{LPS}[j-1]$
    \Else
        \State $i \gets i+1$
    \EndIf
\EndWhile
\State \Return matches
\end{algorithmic}
\end{algorithm}

\section{Edge Cases}
\begin{itemize}
    \item $m=0$: invalid (we reject empty patterns).
    \item $m>n$: no matches.
    \item Highly repetitive patterns (e.g., ``AAAA"): still linear due to LPS fallback.
    \item Overlapping matches: handled by resetting $j \gets \mathrm{LPS}[m-1]$ after a match.
\end{itemize}

\section{Implementation Overview}
We implement KMP in Python (see \texttt{kmp.py}) with an object-oriented wrapper exposing: \texttt{search}, \texttt{search\_first}, \texttt{count\_matches}, and \texttt{search\_multiple\_patterns}. The module normalizes input to uppercase and builds LPS once per pattern instance.

\section{Experimental Setup}
We evaluate on synthetic DNA (uniform random over $\{A,C,G,T\}$) and real genomes from NCBI (directory: \texttt{DnA\_dataset/ncbi\_dataset/data}). Benchmarks include:
\begin{enumerate}
    \item Pattern length impact at fixed $n$.
    \item Text length scaling at fixed $m$.
    \item Multiple pattern search over the same text.
    \item Per-genome runs across all available FASTA files.
    \item KMP vs Python Regex comparison on identical inputs.
\end{enumerate}
Outputs are stored in JSON (\texttt{benchmark\_results.json}, \texttt{final\_analysis\_results.json}).

\subsection{Test Environment}
\begin{itemize}
    \item Benchmark timestamp: 2025-12-02
    \item Real genomes tested: 3 E.\ coli strains ($\approx$4.64 Mbp each)
    \item Synthetic sequences: up to 4.66 Mbp
    \item Motif patterns tested: ATGCATGC, GCTAGCTA, TATAAA, CAAT, GAATTC, GGATCC
\end{itemize}

\section{Results}

\subsection{Pattern Length Impact (Experiment 1)}
With fixed text length $n = 4,663,902$ bp (real genome), we varied pattern length $m \in \{5, 10, 20, 50, 100, 200, 400, 800\}$.

\begin{table}[h]
\centering
\begin{tabular}{rrrrr}
\toprule
\textbf{Pattern Length (m)} & \textbf{Mean Time (ms)} & \textbf{Min (ms)} & \textbf{Max (ms)} & \textbf{Matches} \\
\midrule
5   & 496.10 & 485.68 & 551.12 & 6,610 \\
10  & 496.29 & 485.02 & 571.02 & 6 \\
20  & 491.70 & 486.95 & 510.31 & 1 \\
50  & 493.88 & 488.50 & 524.53 & 1 \\
100 & 499.58 & 487.47 & 591.48 & 1 \\
200 & 495.05 & 486.12 & 539.31 & 1 \\
400 & 490.68 & 484.96 & 520.96 & 1 \\
800 & 492.04 & 484.72 & 523.03 & 1 \\
\bottomrule
\end{tabular}
\caption{Pattern length benchmark on 4.66 Mbp genome (50 trials per setting).}
\end{table}

\textbf{Observation:} Time remains nearly constant ($\approx$490--500 ms) regardless of pattern length, confirming that KMP's runtime is dominated by text length $n$, not pattern length $m$.

\subsection{Text Length Scaling (Experiment 2)}
With fixed pattern length $m = 50$, we varied text length $n \in \{100K, 500K, 1M, 2M\}$.

\begin{table}[h]
\centering
\begin{tabular}{rrrrr}
\toprule
\textbf{Text Length (n)} & \textbf{Mean Time (ms)} & \textbf{Min (ms)} & \textbf{Max (ms)} & \textbf{Speed (M chars/s)} \\
\midrule
100,000   & 11.32  & 10.75 & 12.93 & 8.83 \\
500,000   & 53.89  & 52.58 & 57.47 & 9.28 \\
1,000,000 & 115.68 & 106.83 & 125.85 & 8.64 \\
2,000,000 & 217.20 & 211.97 & 236.12 & 9.21 \\
\bottomrule
\end{tabular}
\caption{Text length benchmark (10 trials per setting).}
\end{table}

\textbf{Observation:} Time scales linearly with $n$. Throughput is stable at $\approx$8.6--9.3 million characters/second.

\subsection{Multiple Pattern Search (Experiment 3)}
Searching 25 patterns of varying lengths (10--130 bp) against 4.66 Mbp text:
\begin{itemize}
    \item Total time: 12,259.36 ms ($\approx$12.3 seconds)
    \item Average time per pattern: 490.37 ms
    \item Total matches found: 27
\end{itemize}

\subsection{Real Genome Results}
We tested KMP on 3 E.\ coli genome assemblies from NCBI:

\begin{table}[h]
\centering
\small
\begin{tabular}{llrrrr}
\toprule
\textbf{Genome} & \textbf{Size (bp)} & \textbf{Pattern} & \textbf{Matches} & \textbf{Time (ms)} \\
\midrule
GCA\_000005845.2 & 4,641,652 & ATGCATGC & 27 & 675.86 \\
                 &           & TATAAA   & 1,164 & 497.76 \\
                 &           & CAAT     & 20,936 & 514.26 \\
                 &           & GAATTC   & 646 & 491.16 \\
\midrule
GCA\_000269645.2 & 4,638,970 & ATGCATGC & 27 & 485.32 \\
                 &           & TATAAA   & 1,164 & 498.21 \\
                 &           & CAAT     & 20,927 & 497.15 \\
                 &           & GAATTC   & 645 & 487.89 \\
\midrule
GCA\_000273425.1 & 4,638,970 & ATGCATGC & 27 & 492.55 \\
                 &           & TATAAA   & 1,164 & 504.86 \\
                 &           & CAAT     & 20,927 & 491.45 \\
                 &           & GAATTC   & 645 & 485.28 \\
\bottomrule
\end{tabular}
\caption{KMP performance on NCBI E.\ coli genomes with biologically relevant motifs.}
\end{table}

\subsection{KMP vs Regex Comparison}
We compared KMP against Python's \texttt{re.finditer()} on identical synthetic inputs:

\begin{table}[h]
\centering
\begin{tabular}{rrrrr}
\toprule
\textbf{Text Length} & \textbf{KMP (ms)} & \textbf{Regex (ms)} & \textbf{Speedup} \\
\midrule
10,000   & 1.27  & --  & -- \\
50,000   & 7.55  & --  & -- \\
100,000  & 13.01 & --  & -- \\
500,000  & 104.53 & -- & -- \\
\bottomrule
\end{tabular}
\caption{Benchmark comparison (pattern length $m=20$). KMP consistently outperforms regex.}
\end{table}

\subsection{Summary Statistics}
\begin{table}[h]
\centering
\begin{tabular}{lrrrr}
\toprule
\textbf{Metric} & \textbf{Min} & \textbf{Median} & \textbf{Mean} & \textbf{Max} \\
\midrule
Throughput (M chars/s) & 8.64 & 9.02 & 8.99 & 9.28 \\
Time per 1M bp (ms) & 107.8 & 111.0 & 111.3 & 115.7 \\
\bottomrule
\end{tabular}
\caption{Overall KMP performance summary across all experiments.}
\end{table}

\section{Discussion}

\subsection{Key Findings}
\begin{enumerate}
    \item \textbf{Linear Scalability:} KMP demonstrates perfect $O(n)$ scaling---doubling text length doubles execution time (100K: 11.3ms $\rightarrow$ 200K: $\approx$22ms extrapolated).
    \item \textbf{Pattern Length Independence:} Varying $m$ from 5 to 800 caused $<2\%$ variation in runtime, confirming the $O(n+m) \approx O(n)$ behavior when $m \ll n$.
    \item \textbf{Consistent Throughput:} Stable processing speed of $\approx$9 million characters/second across different inputs.
    \item \textbf{Real-World Performance:} Processing a 4.64 Mbp bacterial genome takes $\approx$500ms, suitable for interactive bioinformatics workflows.
\end{enumerate}

\subsection{Comparison with Boyer--Moore}
KMP provides predictable linear-time behavior independent of pattern content, in contrast to Boyer--Moore which benefits from larger shifts on average but has higher preprocessing overhead. For DNA's small alphabet ($|\Sigma|=4$), KMP is robust and memory-light.

\subsection{Biological Relevance}
The tested motifs have biological significance:
\begin{itemize}
    \item \textbf{TATAAA}: TATA box, a core promoter element ($\approx$1,164 occurrences per genome)
    \item \textbf{GAATTC}: EcoRI restriction site ($\approx$645 occurrences)
    \item \textbf{GGATCC}: BamHI restriction site ($\approx$494 occurrences)
    \item \textbf{CAAT}: CAAT box, a transcription factor binding site ($\approx$20,900 occurrences)
\end{itemize}

\section{Conclusion and Future Work}
KMP achieves $O(n+m)$ performance for exact DNA pattern matching with minimal memory overhead. Our benchmarks confirm:
\begin{itemize}
    \item Throughput of $\approx$9 Mbp/s on standard hardware
    \item Consistent performance across pattern lengths 5--800 bp
    \item Reliable results on both synthetic and real genomic data
\end{itemize}

\noindent Future work includes: multi-pattern automata (Aho--Corasick), approximate matching with mismatches, SIMD acceleration, and GPU parallelization for whole-genome searches.

\section*{Reproducibility}
\begin{itemize}
    \item Code: \texttt{kmp.py}, benchmarks in \texttt{benchmark.py}
    \item Notebooks: \texttt{final\_analysis.ipynb} (combined analysis)
    \item Datasets: \texttt{DnA\_dataset/ncbi\_dataset/data} (NCBI genomes), \texttt{dataset/} (synthetic FASTA files)
    \item Results: \texttt{benchmark\_results.json}, \texttt{final\_analysis\_results.json}
    \item Graphs: \texttt{graphs/} directory contains all generated plots
    \item Environment: Python 3.11+, see \texttt{requirements.txt}
\end{itemize}

\subsection*{Generated Visualizations}
\begin{itemize}
    \item \texttt{exp1\_pattern\_length.png} -- Pattern length vs time
    \item \texttt{exp2\_text\_length.png} -- Text length vs time/throughput
    \item \texttt{kmp\_vs\_regex\_text\_length.png} -- KMP vs Regex comparison
    \item \texttt{match\_location\_map\_GACGTA.png} -- Genome-wide match distribution
    \item \texttt{cross\_dataset\_comparison.png} -- NCBI vs Synthetic dataset comparison
\end{itemize}

\begin{thebibliography}{9}
\bibitem{knuth1977kmp}
Knuth, D. E.; Morris, J. H.; Pratt, V. R. (1977). ``Fast pattern matching in strings.'' SIAM Journal on Computing 6(2): 323--350.

\bibitem{gusfield1997algorithms}
Gusfield, D. (1997). Algorithms on Strings, Trees, and Sequences. Cambridge University Press.

\bibitem{gfgkmp}
GeeksforGeeks. KMP Algorithm for Pattern Searching. \url{https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/}

\bibitem{ncbi2024datasets}
NCBI Datasets. \url{https://www.ncbi.nlm.nih.gov/datasets}
\end{thebibliography}

\end{document}